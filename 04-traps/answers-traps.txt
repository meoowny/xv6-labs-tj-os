/ Q1: 哪些寄存器保存函数的参数？例如，在 `main` 对 `printf` 的调用中，哪个寄存器保存 13？
/ A1: 调用函数时使用 `a1`、`a2`、`a3` 等通用寄存器保存函数的参数。
      #figure(
        image("..\assets\call-main.png", width: 80%),
        caption: [`call.asm` 中的 `main()` 函数],
      ) <fig-call-main>
      通过查看 `call.asm` 文件的 `main()` 函数可知，在 `main` 调用 `printf` 时，13 被保存在寄存器 `a2` 中。\ \ 

/ Q2: `main` 的汇编代码中在哪里调用了函数 `f`？对 `g` 的调用在哪里（提示：编译器可能会将函数内联）
/ A2: 通过查看函数 `f()` 和 `g()` 可知：函数 `f()` 调用了函数 `g()`，函数 `g()` 将传入的参数加 3 后返回。考虑到编译器会进行内联优化，这就意味着一些编译时可以计算的数据会在编译时得出结果，而不进行函数调用。\ \ 
      查看代码可以发现，函数 `f()` 直接将传入的值加 3 返回；`main()` 函数在 `printf()` 中调用了 `f()` 函数，但对应的汇编代码直接将 `f(8)+1` 替换为 12。这说明编译器对这个函数调用进行了优化。\ \ 
      所以对于 `main` 函数而言，它并没有直接调用 `f()` 函数和 `g()` 函数，`f()` 函数也没有直接调用 `g()` 函数，编译器对其进行了优化。\ \ 

/ Q3: `printf`函数位于哪个地址？
/ A3: 通过搜索可以得到 `printf` 函数的地址为 `0x628`。
      #figure(
        image("..\assets\printf-addr.png", width: 80%),
        caption: [`printf` 函数地址],
      ) <fig-printf-addr>\ \ 

/ Q4: 在 `main` 中 `jalr` 到 `printf` 后寄存器 `ra` 中值是什么？
/ A4: 查看相关代码：
      #figure(
        image("..\assets\main-jalr.png", width: 80%),
        caption: [`main` 中的 `jalr` 指令],
      ) <fig-main-jalr>
      30: 使用 `auipc ra,0x0` 将当前程序计数器 `pc` 的值存入 `ra` 中；\ \ 
      34: 使用 `jalr 1536(ra)` 跳转到偏移地址 `printf` 处，也就是 `0x628` 的位置。\ \ 
      执行完这句指令后，寄存器 `ra` 的值会被设置为 `pc+4`，即 `0x38`。\ \ 
      因此 `jalr` 指令执行完毕之后，`ra` 的值为 `0x38`。\ \ 
/ Q5: 运行以下代码：
      #blockquote[
      ```c
      unsigned int i = 0x00646c72;
      printf("H%x Wo%s", 57616, &i);
      ```
      ]
      指出程序的输出是什么样的。\ \ 
      输出取决这样一个事实，即 RISC-V 使用小端存储。如果 RISC-V 是大端存储，为了得到相同的输出，你会把 `i` 设置成什么？是否需要将 `57616` 更改为其他值？\ \ 
/ A5: 运行结果：打印出了 `HE110 World`。\ \ 
      这是因为 `57616` 转换为十六进制后为 `E110`，因此格式化后打印出了它的十六进制值。而在小端处理器中，数据 `0x00646c72` 的高字节存储在内存的高位，从内存低位（即低字节）开始读取时，对应的 ASCII 字符就是 `rld`。\ \ 
      如果是在大端处理器中，数据高字节存储在内存低位中，所以如果需要和小端序输出相同内容的话，就需要将 `i` 的值改为 `0x726c64` 才能保证内存从低位读取时输出为 `rld`。\ \ 
      而 `57616` 的二进制值无关存储方式，因此不需要改变。\ \ 
      总的来说，需要将 `i` 的值改为 `0x726c64`，`57616` 不需要改变。\ \ 

/ Q6: 在下面的代码中，`y=` 后面将打印什么（注：答案不是一个特定的值）？为什么会发生这种情况？
      #blockquote[
      ```c
      printf("x=%d y=%d", 3);
      ```
      ]
/ A6: 由于函数参数是通过 `a1`, `a2` 等寄存器来传递的，因此如果 `printf` 少传一个参数，它就仍会从指定寄存器中读取想要的参数的值。但由于这里没有给出该参数，因此函数从寄存器 `a2` 中的读取到的值无法确定。
